{"name":"Glass-Rails","tagline":"A DSL for building Google Glass apps using Ruby on Rails. ","body":"## Glass-Rails\r\n\r\nThis is a ruby gem extracted out of [Thirst Droplet](http://thirst.co/glass), a google glass application. The goal of this gem is to provide a more convenient wrapper around the official [Google Api Client for Ruby](https://github.com/google/google-api-ruby-client). This gem is still quite young, and in development, so keep posted for updates (and we also <3 pull requests). \r\n\r\n## Installation \r\nAdd the following to your Gemfile and then run `bundle install`.\r\n\r\n```ruby\r\ngem 'google-api-client' # this is a dependency\r\ngem 'glass-rails'\r\n```\r\n\r\nOr you can install the gem locally, by running the following command in the terminal:\r\n\r\n```shell\r\n$ gem install glass-rails\r\n```\r\n\r\n## Basic Setup\r\n\r\nIn order to get this gem setup for use, we require that you have some sort of user model already in place. You can, for example, have a `devise` generated User model, or a custom hand-rolled user model. \r\n\r\nFor convenience, this gem provides a command to scaffold some necessary files for glass development:\r\n\r\n```shell\r\n$ rails g glass:install <optional_name_of_user_model>\r\n                       # defaults to 'User'\r\n```\r\n\r\nIf the name of user model is not `User` then you must specify this when invoking the `glass:install` command:\r\n\r\n```shell\r\n$ rails g glass:install person\r\n```\r\n\r\n### Files created by the `glass:install` generator\r\n\r\n1. A `config/google-api-keys.yml` file for your client_id and client_secret api keys for accessing the mirror api.\r\n2. A Glass::Rails initializer file in `config/initializers/glass.rb` for setting up default view paths for your glass templates.\r\n3. Generates a `app/models/google_account.rb` model which is automatically associated to your user model.\r\n4. A controller is created for 'listening' to subscription notifications from your glass users. \r\n\r\n## Pre-defined Templates for Glass\r\n\r\nThis gem also includes pre-defined erb templates for use with timeline items. You can generate these templates for use by running the following command: \r\n\r\n```shell\r\n$ rails g glass:templates\r\n```\r\n\r\nThis will generate a name-spaced folder in your `app/views` directory called `glass` and populate it with a few useful predefined templates. \r\n\r\n## Creating Timeline Items \r\n\r\nThis gem also includes a generator for creating an ActiveRecord backed timeline item or a \"glass model\". \r\n\r\n## Glass::TimelineItem (a superclass which you'll be inheriting from)\r\n\r\nThe Glass::TimelineItem class is a subclass of ActiveRecord which is, for all intents and purposes, an abstract class. We've basically added a few convenience methods to ActiveRecord which allows for the easy population of custom menu items and some procedures for serializing these items for posting them to the glass timeline. \r\n\r\n### The TimelineItem Generator\r\n\r\nYou can generate a timeline_item model by executing the following command:\r\n\r\n```shell\r\n$ rails g glass:model <name of model>\r\n```\r\n\r\nSo, for the sake of illustration, let's say you wanted to generate a tweet model, which you intend to use to post particular tweets to a glass user's timeline. I would, then, execute this command:\r\n\r\n```shell\r\n$ rails g glass:model tweet\r\n```\r\n\r\nThis would create a model for me in the following directory `app/models/glass/tweet.rb`. This `Glass::Tweet` model would inherit from `Glass::TimelineItem` and would therefore be accompanied by a sugary goodness which makes posting to glass timelines a ton easier. \r\n\r\n### Setting up a Glass Model\r\n\r\n***\r\n\r\n#### Defining a Default Template\r\nYou may want to specify a default template to use for a given timeline item. For example, if I had two timeline item models, `Glass::Tweet` and another `Glass::BasketballScore`, then I could specify a default template for the tweet model to use by using a helper_method in the class definition, like so:\r\n\r\n```ruby\r\nclass Glass::Tweet < Glass::TimelineItem\r\n  defaults_template with: \"tweet.html.erb\" ## this path is relative to \r\n                                           ## your glass_templates_path, \r\n                                           ## which you can set in your\r\n                                           ## `config/initializers/glass.rb` \r\n                                           ## file.\r\n\r\nend\r\n```\r\nand then you could define another default template for your basketball score model like so:\r\n\r\n```ruby\r\nclass Glass::BasketballScore < Glass::TimelineItem\r\n  defaults_template with: \"two_column.html.erb\" ## since this would make\r\n                                                ## sense if wanted to show \r\n                                                ## a score in each column.\r\nend\r\n```\r\n\r\n#### Defining Menu Items on the Timeline Item\r\n\r\nThis gem provides some meta-programming magic to ease the creation of both custom and built-in menu-items for glass, by providing an easy to use DSL for specifying custom and built-in menu-items that a timeline-item should have..\r\n\r\nFor example, let's say I want to have two default actions on my `Glass::Tweet` object: 1) email this tweet to me. 2) read the tweet to me aloud. \r\n\r\nInside my `Glass::Tweet` class definition, I would specify these actions like so:\r\n\r\n```ruby \r\nclass Glass::Tweet < Glass::TimelineItem\r\n  has_menu_item :email, icon_url: \"http://www.example.com/example-email-icon.png\",\r\n                        display_name: \"Email\", # this is what is shown \r\n                                               # as text for the menu item\r\n                        handles_with: :email_callback \r\n                                               # we'll ignore this for now.\r\n  has_menu_item :read_aloud ## this is a built-in action.\r\n\r\nend\r\n```\r\n\r\nThis would basically define two actions for all items posted with this glass model, i.e. Email & Read Aloud.\r\n\r\nYou can define a different set of menu items for each model, so that would probably be something to consider when architecting your glass app. \r\n\r\n## Inserting a Timeline Item to Glass\r\n\r\nFor the sake of simplicity, let's continue with the example we've been using so far, the `Glass::Tweet` model. If we had a hypothetical tweet:\r\n\r\n```ruby\r\n@tweet = { \r\n  content: \"Rails is omakase\", \r\n  author: \"@dhh\" \r\n}\r\n```\r\n\r\nIf we wanted to post it to a glass user's timeline, we would first initialize a `Glass::Tweet` object and associate it to the google account that we want to send this tweet.\r\n\r\n```ruby\r\n@tweet_timeline_object = Glass::Tweet.new(google_account_id: GoogleAccount.first.id)\r\n```\r\n\r\nThen, we can serialize our html for posting by executing this command:\r\n\r\n```ruby\r\n@tweet_timeline_object.serialize(template_variables: {tweet_content: @tweet[:content], \r\n                                                      author: @tweet[:author]})\r\n\r\n### if you pass in a key named \"template_name\" \r\n### into the single argument that `serialize`\r\n### takes as a method, then you can also \r\n### override the default template rendered for \r\n### instances of this class.\r\n\r\n### For example:\r\n@tweet_timeline_object.serialize(template_variables: {tweet_content: @tweet[:content], \r\n                                                      author: @tweet[:author]},\r\n                                 template_name: \"dramatic-tweet.html.erb\")\r\n### will render this tweet into the template located \r\n### in `app/views/glass/dramatic-tweet.html.erb` \r\n### provided you haven't overridden glass_templates_path\r\n### in your glass initializer.\r\n```\r\n\r\n## How `Serialize` connects with our Glass Template\r\n\r\nWhen we invoke the `serialize` method on glass timeline item object, we will populate your template, which should be\r\neither the default template for your timeline item class or a manually specified template in the serialize method, with instance variables, each of which correspond to key-value pairs contained within `template_variables`. \r\n\r\nSo for our example above, this would mean:\r\n\r\n```ruby\r\n### since we passed this hash:\r\n### {template_variables: {tweet_content: \"Rails is omakase\",\r\n###                       author: \"@dhh\"}}\r\n### we will populate our template with the following variables:\r\n\r\n@tweet_content = \"Rails is omakase\"\r\n@author = \"@dhh\"\r\n### note: the values passed into the serialize method \r\n###       do not have to be simple data types, they\r\n###       can be full-fledged objects too.\r\n```\r\n\r\nso given an erb template that looks like this:\r\n\r\n```erb\r\n<article>\r\n  <section><%= @tweet_content %></section>\r\n  <footer><%= @author %></footer>\r\n</article>\r\n```\r\nWe would be creating a html serialization of your data, which \r\nwould look like this:\r\n\r\n```html\r\n<article>\r\n  <section>Rails is omakase</section>\r\n  <footer>@dhh</footer>\r\n</article>\r\n```\r\n\r\nNote: If you want to inspect that your html is getting serialized properly, you can inspect the html yourself by calling to_json on your timeline_item object. This will return a ruby hash which has the html serialization as well as the array of menu items which you intend to post with your timeline item.\r\n\r\nAnd finally, to post to our timeline, we can call this command:\r\n\r\n```ruby\r\n@tweet_timeline_object.insert()\r\n```\r\n\r\n***\r\n\r\n### Subscriptions / Notifications\r\n\r\nThe mirror api lets you subscribe to notifications on Timeline Items. For each user you want to subscribe to notifications for, you must register a callback url with that user's credentials. When a user does an action (delete, custom action, reply, etc.) on a timeline item, Google will post back to that callback url.\r\n\r\nA subscription to Google has 5 main parts\r\n* callbackUrl: Note that this must be HTTPS, so it won't work in development mode.\r\n* collection: This can be 'timeline' or 'location'\r\n* verifyToken: This is optional, but lets you verify that the request came from Google. Out of the box, we have set GoogleAccounts to have a randomly generated field called verification_secret that we automatically set as the verifyToken\r\n* userToken: This is an optional string that Google will always pass back for a particular user. We have set this to be GoogleAccount.id\r\n* operations: A list of action types (Insert, Update, Delete) you would want to be notified about\r\n\r\nSubscriptions was probably the hardest part to test, but we've included some tools that should make it easier to deal with them.\r\n\r\nA GoogleAccount, on creation, will subscribe to the Google callback service with the route glass_notifications_callback_url, which we've defined in the Glass installer. The Glass Notifications controller will then handle Google's post and call the appropriate methods within the TimelineItem.\r\n\r\nFor example, if a glass user activates the menu-item `email`, then our glass app would get pinged on our subscription notification callback url. From here, we've implemented a callback handler which allows you to easily manipulate any callback logic, in the comfort of your timeline item model. \r\n\r\n```ruby\r\n  has_menu_item :email,\r\n       icon_url: \"http://example.com/test.jpg\"\r\n       display_name: \"Email This!\"\r\n       handles_with: :email_callback_method\r\n\r\n  def email_callback_method\r\n    # Email this timeline item content to someone\r\n  end\r\n```\r\n\r\nThe method `email_callback_method` gets executed whenever your subscription notification callback url is pinged with the corresponding menu-item event. \r\n\r\nYou can also add Google's built in menu items:\r\n\r\n```ruby\r\n  has_menu_item :read_aloud\r\n```\r\n\r\nNote that most of the built in timeline actions (but not all) do not trigger callbacks from Google. Exceptions include reply, delete, and share.\r\n\r\n***\r\n\r\n### Plans for the Future\r\n\r\nThis framework is still young and being actively developed. We <3 bug reports and pull requests.\r\n\r\n### To-dos\r\n\r\n1. Work out a wrapper for the mirror location api\r\n2. Handle all built-in menu-items properly\r\n3. Figure something out for attachments\r\n\r\n\r\n## Copyright / License\r\n```\r\nCopyright (c) 2013 Thirst Labs, Inc.\r\n\r\nMIT License\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n```\r\n\r\n###### Authors: \r\n###### Kunal Modi & Han Kang \r\n###### (of Thirst Labs, Inc.)","google":"UA-41071469-1","note":"Don't delete this file! It's used internally to help with page regeneration."}