{"name":"Glass-Rails","tagline":"A DSL for building Google Glass apps using Ruby on Rails. ","body":"## Glass-Rails\r\n\r\nThis is a ruby gem extracted out of [Thirst Droplet](http://thirst.co/glass), a google glass application. The goal of this gem is to provide a more convenient wrapper around the official [Google Api Client for Ruby](https://github.com/google/google-api-ruby-client). This gem is still quite young, and in development, so keep posted for updates (and we also <3 pull requests). \r\n\r\n## Installation \r\nAdd the following to your Gemfile and then run `bundle install`.\r\n\r\n```ruby\r\ngem 'glass-rails'\r\n```\r\n\r\nOr you can install the gem locally, by running the following command in the terminal:\r\n\r\n```shell\r\n$ gem install glass-rails\r\n```\r\n\r\n## Basic Setup\r\n\r\nIn order to get this gem setup for use, we require that you have some sort of user model already in place. You can, for example, have a `devise` generated User model, or a custom hand-rolled user model. \r\n\r\nFor convenience, this gem provides a command to scaffold some necessary files for glass development:\r\n\r\n```shell\r\n$ rails g glass:install <optional_name_of_user_model>\r\n                       # defaults to 'User'\r\n```\r\n\r\nIf the name of user model is not `User` then you must specify this when invoking the `glass:install` command:\r\n\r\n```shell\r\n$ rails g glass:install person\r\n```\r\n\r\n### Files created by the `glass:install` generator\r\n\r\n1. A `config/google-api-keys.yml` file for your client_id and client_secret api keys for accessing the mirror api.\r\n2. A Glass::Rails initializer file in `config/initializers/glass.rb` for setting up default view paths for your glass templates.\r\n3. Generates a `app/models/google_account.rb` model which is automatically associated to your user model.\r\n4. A controller is created for 'listening' to subscription notifications from your glass users. \r\n\r\n## Pre-defined Templates for Glass\r\n\r\nThis gem also includes pre-defined erb templates for use with timeline items. You can generate these templates for use by running the following command: \r\n\r\n```shell\r\n$ rails g glass:templates\r\n```\r\n\r\nThis will generate a name-spaced folder in your `app/views` directory called `glass` and populate it with a few useful predefined templates. \r\n\r\n## Creating Timeline Items \r\n\r\nThis gem also includes a generator for creating an ActiveRecord backed timeline item or a \"glass model\". \r\n\r\n## Glass::TimelineItem (a superclass which you'll be inheriting from)\r\n\r\nThe Glass::TimelineItem class is a subclass of ActiveRecord which is, for all intents and purposes, an abstract class. We've basically added a few convenience methods to ActiveRecord which allows for the easy population of custom menu items and some procedures for serializing these items for posting them to the glass timeline. \r\n\r\n### The TimelineItem Generator\r\n\r\nYou can generate a timeline_item model by executing the following command:\r\n\r\n```shell\r\n$ rails g glass:model <name of model>\r\n```\r\n\r\nSo, for the sake of illustration, let's say you wanted to generate a tweet model, which you intend to use to post particular tweets to a glass user's timeline. I would, then, execute this command:\r\n\r\n```shell\r\n$ rails g glass:model tweet\r\n```\r\n\r\nThis would create a model for me in the following directory `app/models/glass/tweet.rb`. This `Glass::Tweet` model would inherit from `Glass::TimelineItem` and would therefore be accompanied by a sugary goodness which makes posting to glass timelines a ton easier. \r\n\r\n### Setting up a Glass Model\r\n\r\n***\r\n\r\n#### Defining a Default Template\r\nYou may want to specify a default template to use for a given timeline item. For example, if I had two timeline item models, `Glass::Tweet` and another `Glass::BasketballScore`, then I could specify a default template for the tweet model to use by using a helper_method in the class definition, like so:\r\n\r\n```ruby\r\nclass Glass::Tweet < Glass::TimelineItem\r\n  defaults_template with: \"tweet.html.erb\" ## this path is relative to \r\n                                           ## your glass_templates_path, \r\n                                           ## which you can set in your\r\n                                           ## `config/initializers/glass.rb` \r\n                                           ## file.\r\n\r\nend\r\n```\r\nand then you could define another default template for your basketball score model like so:\r\n\r\n```ruby\r\nclass Glass::BasketballScore < Glass::TimelineItem\r\n  defaults_template with: \"two_column.html.erb\" ## since this would make\r\n                                                ## sense if wanted to show \r\n                                                ## a score in each column.\r\nend\r\n```\r\n\r\n#### Defining Menu Items on the Timeline Item\r\n\r\nThis gem provides some meta-programming magic to ease the creation of both custom and built-in menu-items for glass, by providing an easy to use DSL for specifying custom and built-in menu-items that a timeline-item should have..\r\n\r\nFor example, let's say I want to have two default actions on my `Glass::Tweet` object: 1) email this tweet to me. 2) read the tweet to me aloud. \r\n\r\nInside my `Glass::Tweet` class definition, I would specify these actions like so:\r\n\r\n```ruby \r\nclass Glass::Tweet < Glass::TimelineItem\r\n  has_menu_item :email, icon_url: \"http://www.example.com/example-email-icon.png\",\r\n                        display_name: \"Email\", # this is what is shown \r\n                                               # as text for the menu item\r\n                        handles_with: :email_callback \r\n                                               # we'll ignore this for now.\r\n  has_menu_item :read_aloud ## this is a built-in action.\r\n\r\nend\r\n```\r\n\r\nThis would basically define two actions for all items posted with this glass model, i.e. Email & Read Aloud.\r\n\r\nYou can define a different set of menu items for each model, so that would probably be something to consider when architecting your glass app. \r\n\r\n## Inserting a Timeline Item to Glass\r\n\r\nFor the sake of simplicity, let's continue with the example we've been using so far, the `Glass::Tweet` model. If we had a hypothetical tweet:\r\n\r\n```ruby\r\n@tweet = { \r\n  content: \"Rails is omakase\", \r\n  author: \"@dhh\" \r\n}\r\n```\r\n\r\nIf we wanted to post it to a glass user's timeline, we would first initialize a `Glass::Tweet` object and associate it to the google account that we want to send this tweet.\r\n\r\n```ruby\r\n@tweet_timeline_object = Glass::Tweet.new(google_account_id: GoogleAccount.first.id)\r\n```\r\n\r\nThen, we can serialize our html for posting by executing this command:\r\n\r\n```ruby\r\n@tweet_timeline_object.serialize(template_variables: {tweet_content: @tweet[:content], \r\n                                                      author: @tweet[:author]})\r\n\r\n### if you pass in a key named \"template_name\" \r\n### into the single argument that `serialize`\r\n### takes as a method, then you can also \r\n### override the default template rendered for \r\n### instances of this class.\r\n\r\n### For example:\r\n@tweet_timeline_object.serialize(template_variables: {tweet_content: @tweet[:content], \r\n                                                      author: @tweet[:author]},\r\n                                 template_name: \"dramatic-tweet.html.erb\")\r\n### will render this tweet into the template located \r\n### in `app/views/glass/dramatic-tweet.html.erb` \r\n### provided you haven't overridden glass_templates_path\r\n### in your glass initializer.\r\n```\r\n\r\n## How `Serialize` connects with our Glass Template\r\n\r\nWhen we invoke the `serialize` method on glass timeline item object, we will populate your template, which should be\r\neither the default template for your timeline item class or a manually specified template in the serialize method, with instance variables, each of which correspond to key-value pairs contained within `template_variables`. \r\n\r\nSo for our example above, this would mean:\r\n\r\n```ruby\r\n### since we passed this hash:\r\n### {template_variables: {tweet_content: \"Rails is omakase\",\r\n###                       author: \"@dhh\"}}\r\n### we will populate our template with the following variables:\r\n\r\n@tweet_content = \"Rails is omakase\"\r\n@author = \"@dhh\"\r\n### note: the values passed into the serialize method \r\n###       do not have to be simple data types, they\r\n###       can be full-fledged objects too.\r\n```\r\n\r\nso given an erb template that looks like this:\r\n\r\n```erb\r\n<article>\r\n  <section><%= @tweet_content %></section>\r\n  <footer><%= @author %></footer>\r\n</article>\r\n```\r\nWe would be creating a html serialization of your data, which \r\nwould look like this:\r\n\r\n```html\r\n<article>\r\n  <section>Rails is omakase</section>\r\n  <footer>@dhh</footer>\r\n</article>\r\n```\r\n\r\nNote: If you want to inspect that your html is getting serialized properly, you can inspect the html yourself by calling to_json on your timeline_item object. This will return a ruby hash which has the html serialization as well as the array of menu items which you intend to post with your timeline item.\r\n\r\nAnd finally, to post to our timeline, we can call this command:\r\n\r\n```ruby\r\n@tweet_timeline_object.insert()\r\n```\r\n\r\n***\r\n\r\n### Subscriptions / Notifications\r\n\r\nThe subscription/notification aspect of the mirror api is probably one of the most opaque aspects of the api (at least, in my opinion), but we've tried to include some tools to help get this part set up for you as well. \r\n\r\nBasically, you need to register a callback url for your glass subscriptions, and you will get notified when a glass user invokes a custom menu item. \r\n\r\nFor example, if a glass user activates the menu-item `email`, then our glass app would get pinged on our subscription notification callback url. From here, we've implemented a callback handler which allows you to easily manipulate any callback logic, in the comfort of your timeline item model. \r\n\r\nSpecifically, whenever you define a custom menu item using our helper method:\r\n\r\n```ruby\r\n  ..\r\n  has_menu_item :email, ..\r\n       ..\r\n       handles_with: :email_callback_method\r\n```\r\n\r\nWe've ensured that the method `email_callback_method` gets executed whenever your subscription notification callback url is pinged with the corresponding menu-item event. \r\n\r\n***\r\n\r\nThis framework is still young and being actively developed. We <3 bug reports and pull requests.\r\n\r\n## Copyright / License\r\n```\r\nCopyright (c) 2013 Thirst Labs, Inc.\r\n\r\nMIT License\r\n\r\nPermission is hereby granted, free of charge, to any person obtaining\r\na copy of this software and associated documentation files (the\r\n\"Software\"), to deal in the Software without restriction, including\r\nwithout limitation the rights to use, copy, modify, merge, publish,\r\ndistribute, sublicense, and/or sell copies of the Software, and to\r\npermit persons to whom the Software is furnished to do so, subject to\r\nthe following conditions:\r\n\r\nThe above copyright notice and this permission notice shall be\r\nincluded in all copies or substantial portions of the Software.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND,\r\nEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\r\nMERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\r\nNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE\r\nLIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\r\nOF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION\r\nWITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.\r\n```\r\n\r\nAuthors: \r\n\r\nKunal Modi & Han Kang \r\n(of Thirst Labs, Inc.)","google":"UA-41071469-1","note":"Don't delete this file! It's used internally to help with page regeneration."}